<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magnetic Voxel Storm</title>
    <style>
        body {
            margin: 0;
            background-color: #050505;
            overflow: hidden;
            font-family: sans-serif;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #000;
            line-height: 1.5;
        }
    </style>
</head>
<body>

    <div id="ui">
        3D Magnetic Clouds<br>
        Red (Left) vs Blue (Right)<br>
        Touch & Drag to Disrupt<br>
        Scroll/Pinch to Zoom
    </div>

    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.Fog(0x050505, 20, 500);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 80); // Adjusted angle for 3D view
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- Magnetic Poles Setup ---
        const poleDistance = 25;
        const poleLeftPos = new THREE.Vector3(-poleDistance, 0, 0);
        const poleRightPos = new THREE.Vector3(poleDistance, 0, 0);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0x222222, 1); 
        scene.add(ambientLight);

        // Red Light (Left Pole)
        const lightLeft = new THREE.PointLight(0xff0055, 5, 150);
        lightLeft.position.copy(poleLeftPos);
        scene.add(lightLeft);

        // Blue Light (Right Pole)
        const lightRight = new THREE.PointLight(0x0088ff, 5, 150);
        lightRight.position.copy(poleRightPos);
        scene.add(lightRight);
        
        // Helper markers for the poles
        const poleGeo = new THREE.IcosahedronGeometry(1, 0);
        const meshLeft = new THREE.Mesh(poleGeo, new THREE.MeshBasicMaterial({color: 0xff0055, wireframe: true}));
        meshLeft.position.copy(poleLeftPos);
        scene.add(meshLeft);

        const meshRight = new THREE.Mesh(poleGeo, new THREE.MeshBasicMaterial({color: 0x0088ff, wireframe: true}));
        meshRight.position.copy(poleRightPos);
        scene.add(meshRight);

        // --- Voxel System ---
        const count = 5000; // Increased count for better cloud volume
        const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.4,
            metalness: 0.7
        });

        const mesh = new THREE.InstancedMesh(geometry, material, count);
        scene.add(mesh);

        const dummy = new THREE.Object3D();
        const color = new THREE.Color();
        const upVector = new THREE.Vector3(0, 1, 0); // Axis of rotation
        
        const particles = [];
        
        // Initialize particles in two distinct clouds
        for (let i = 0; i < count; i++) {
            // 50/50 chance to belong to Left or Right cloud initially
            const isLeft = Math.random() > 0.5;
            const center = isLeft ? poleLeftPos : poleRightPos;
            
            // Spherical distribution
            const r = Math.random() * 15; // Cloud radius
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1); // Uniform sphere distribution
            
            const px = center.x + r * Math.sin(phi) * Math.cos(theta);
            const py = center.y + r * Math.sin(phi) * Math.sin(theta);
            const pz = center.z + r * Math.cos(phi);

            particles.push({
                x: px, y: py, z: pz,
                vx: 0, vy: 0, vz: 0,
                noiseOffset: Math.random() * 100,
                homePole: isLeft ? 'left' : 'right' // Prefer one side initially
            });
        }

        // --- Interaction Setup ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Interaction plane
        const interactionPoint = new THREE.Vector3();
        let isInteracting = false;

        // --- Animation Loop ---
        let time = 0;
        let camRadius = 90;
        let camTheta = Math.PI / 2.5; // Lower angle to look from side/top
        let camPhi = Math.PI / 2;
        let prevMouse = { x: 0, y: 0 };

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            if (isInteracting) {
                camera.getWorldDirection(plane.normal);
                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(plane, interactionPoint);
            }

            for (let i = 0; i < count; i++) {
                const p = particles[i];
                const pos = new THREE.Vector3(p.x, p.y, p.z);

                // --- 3D CLOUD PHYSICS ---

                // Calculate vectors to poles
                const vecToLeft = new THREE.Vector3().subVectors(pos, poleLeftPos);
                const distLeft = vecToLeft.length();
                const vecToRight = new THREE.Vector3().subVectors(pos, poleRightPos);
                const distRight = vecToRight.length();

                // 1. Orbital Spin (Tangential Force)
                // Left cloud spins Clockwise, Right spins Counter-Clockwise
                const spinForceLeft = new THREE.Vector3().crossVectors(vecToLeft, upVector).normalize();
                const spinForceRight = new THREE.Vector3().crossVectors(vecToRight, upVector).normalize().negate();

                // 2. Gravity (Attraction to poles to maintain cloud shape)
                // Pulls particles back towards the center of the pole
                const gravityLeft = vecToLeft.clone().normalize().negate(); // Points TO left pole
                const gravityRight = vecToRight.clone().normalize().negate(); // Points TO right pole

                // Calculate Field Strengths (Inverse Square Law)
                const strLeft = 400 / (distLeft * distLeft + 20);
                const strRight = 400 / (distRight * distRight + 20);

                // Apply Spin
                p.vx += spinForceLeft.x * strLeft * 0.05;
                p.vz += spinForceLeft.z * strLeft * 0.05;
                
                p.vx += spinForceRight.x * strRight * 0.05;
                p.vz += spinForceRight.z * strRight * 0.05;

                // Apply 3D Gravity (Holds the cloud together)
                // We use weaker gravity so they stay fluffy
                p.vx += gravityLeft.x * strLeft * 0.03;
                p.vy += gravityLeft.y * strLeft * 0.03;
                p.vz += gravityLeft.z * strLeft * 0.03;

                p.vx += gravityRight.x * strRight * 0.03;
                p.vy += gravityRight.y * strRight * 0.03;
                p.vz += gravityRight.z * strRight * 0.03;

                // 3. Noise & Turbulence (The "Voxel Storm" feel)
                p.vx += (Math.sin(time + p.y * 0.1) - 0.5) * 0.02;
                p.vy += (Math.cos(time + p.x * 0.1) - 0.5) * 0.02;
                p.vz += (Math.sin(time + p.z * 0.1) - 0.5) * 0.02;

                // Interaction
                if (isInteracting) {
                    const idx = p.x - interactionPoint.x;
                    const idy = p.y - interactionPoint.y;
                    const idz = p.z - interactionPoint.z;
                    const idistSq = idx*idx + idy*idy + idz*idz;

                    if (idistSq < 900) { 
                        const force = (900 - idistSq) * 0.002;
                        p.vx += idx * force * 0.1;
                        p.vy += idy * force * 0.1;
                        p.vz += idz * force * 0.1;
                    }
                }

                // Viscosity
                p.vx *= 0.93;
                p.vy *= 0.93;
                p.vz *= 0.93;

                // Update Position
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;

                // Boundary / Respawn Logic
                // If a particle drifts too far from BOTH poles, reset it to a random cloud center
                if (distLeft > 40 && distRight > 40) {
                     // Respawn logic
                     const isLeft = Math.random() > 0.5;
                     const center = isLeft ? poleLeftPos : poleRightPos;
                     const r = Math.random() * 5; 
                     // Respawn near core
                     p.x = center.x + (Math.random()-0.5)*r;
                     p.y = center.y + (Math.random()-0.5)*r;
                     p.z = center.z + (Math.random()-0.5)*r;
                     p.vx = 0; p.vy = 0; p.vz = 0;
                }

                // --- Voxel Rendering ---
                const snapX = Math.round(p.x);
                const snapY = Math.round(p.y);
                const snapZ = Math.round(p.z);

                dummy.position.set(snapX, snapY, snapZ);
                
                // Scale effect at the boundary (center)
                // If roughly equal pull, scale up slightly
                const ratio = strRight / (strLeft + strRight + 0.0001);
                let scale = 1;
                if (ratio > 0.4 && ratio < 0.6) scale = 1.3; // Turbulent center
                
                dummy.scale.setScalar(scale);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);

                // --- Color Mixing ---
                const colorL = new THREE.Color(0xff0055); // Red
                const colorR = new THREE.Color(0x0088ff); // Blue
                const colorMix = new THREE.Color(0xffffff); // White center

                // Interpolate color based on which pole is stronger
                color.lerpColors(colorL, colorR, ratio);
                
                // Add white hot center where fields collide
                if (ratio > 0.45 && ratio < 0.55) {
                    color.lerp(colorMix, 0.7);
                }
                
                mesh.setColorAt(i, color);
            }

            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;

            // Camera Orbit
            camera.position.x = camRadius * Math.sin(camTheta) * Math.cos(camPhi);
            camera.position.y = camRadius * Math.cos(camTheta);
            camera.position.z = camRadius * Math.sin(camTheta) * Math.sin(camPhi);
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        animate();

        // --- Interaction Handlers ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function handleInputStart(x, y) {
            isInteracting = true;
            prevMouse = { x, y };
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
        }

        function handleInputMove(x, y) {
            if (isInteracting) {
                mouse.x = (x / window.innerWidth) * 2 - 1;
                mouse.y = -(y / window.innerHeight) * 2 + 1;
                
                const deltaX = (x - prevMouse.x) * 0.005;
                const deltaY = (y - prevMouse.y) * 0.005;
                camPhi += deltaX;
                camTheta = Math.max(0.1, Math.min(Math.PI - 0.1, camTheta - deltaY));
                prevMouse = { x, y };
            }
        }

        function handleInputEnd() {
            isInteracting = false;
        }

        document.addEventListener('mousedown', e => handleInputStart(e.clientX, e.clientY));
        document.addEventListener('mousemove', e => handleInputMove(e.clientX, e.clientY));
        document.addEventListener('mouseup', handleInputEnd);

        document.addEventListener('touchstart', e => { 
            if(e.touches.length === 1) handleInputStart(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        
        document.addEventListener('touchmove', e => {
            if (e.touches.length === 1) {
                e.preventDefault();
                handleInputMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});

        document.addEventListener('touchend', handleInputEnd);

        document.addEventListener('wheel', e => {
            camRadius += e.deltaY * 0.05;
            camRadius = Math.max(10, Math.min(500, camRadius)); 
        }, {passive: true});

    </script>
</body>
</html>
